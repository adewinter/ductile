import time
import os
import json
from pathlib import Path

from config import DEBUG, DEBUG_VERBOSE
from util import get_actionable_events


class Blob:
    """
    Base class for storing a variable amount of string data.  Typically a blob would wrap a regular text file
    but could actually be anything capable of reading and writing data
    """

    def __init__(self, name):
        self.name = name
        self.last_touch = time.time()
        self.is_active = True

    def get_all_data(self):
        pass

    def save_keystroke(self, event):
        """
        `event` is an event generated by the `keyboard` pip library
        """
        pass

    def close(self):
        """
        close up whatever needs to be closed and mark self as .is_active = False
        """
        pass


class FileBlob(Blob):
    def __init__(self, name, data_folder, process_info):
        super().__init__(name)
        self.write_counter = 0  # used for periodically `flush`ing the file object
        self.FILE_BLOB_FOLDER = Path(data_folder)
        self.FILE_PATH = self.FILE_BLOB_FOLDER / name

        is_active, blob_file = self._get_or_create_file()
        self.file = blob_file
        self.is_active = is_active
        self._optionally_save_header(process_info)
        if DEBUG:
            print(f"Created FileBlob Object: {self}")

    def _optionally_save_header(self, process_info):
        is_file_empty = os.path.getsize(self.FILE_PATH) == 0

        if is_file_empty:
            header = self._generate_header(process_info)
            self._save_string(header)

    def _get_or_create_file(self):
        is_active = False
        file_exists = os.path.exists(self.FILE_PATH)

        try:
            if DEBUG:
                if not file_exists:
                    print(f"Creating new file on disk at: {self.FILE_PATH}")
            blob_file = open(self.FILE_PATH, "a+b")
            is_active = True
        except OSError as e:
            print(f"Could not open file {self.FILE_PATH}:", e)

        return is_active, blob_file

    def _generate_header(self, process_info):
        header = f"""==================#$%@ DUCTILE HEADER ==================
Process info that created this file:BEGINJSON
{json.dumps(process_info, indent=4)}
ENDJSON

FileBlob info:
    Name: {self.name}
==================#$%@ END DUCTILE HEADER ==============
        """
        if DEBUG:
            print(f"Generated header:\n{header}")
        return header

    def __repr__(self):
        return f"[FileBlob] [{self.FILE_BLOB_FOLDER}][{self.name}]"

    def check_active_or_raise(self):
        if not self.is_active:
            raise Exception(
                f"This FileBlob is already marked as inactive. File: {self.FILE_PATH}"
            )

    def get_all_data(self):
        self.check_active_or_raise()
        out = self.file.readlines()
        self.file.seek(0)
        return out

    def save_keystroke(self, event):
        if DEBUG and DEBUG_VERBOSE:
            print(f"key is:{event.name}")
        actionable_events = get_actionable_events(event)

        if len(actionable_events) == 0:
            if DEBUG and DEBUG_VERBOSE:
                print(f"skipping key: {event.name}")
            return

        if len(actionable_events) > 1:
            keystroke = self._generate_compound_keystroke(actionable_events)
        else:
            keystroke = event.name

        match keystroke:
            case "space":
                self._save_string(" ")
            case "enter":
                self._save_string("\n")
            case "backspace":
                self._handle_backspace_char()
            case _:
                self._save_string(keystroke)

    def _generate_compound_keystroke(self, actionable_events):
        runes = "+".join([event.name for event in actionable_events])
        return f"[{runes}]"

    def _save_string(self, line):
        """
        Save the provided string to the end of the file
        """

        self.check_active_or_raise()
        if DEBUG and DEBUG_VERBOSE:
            print(f"Saving '{line.encode()}' to {self}.")
        self.file.write(line.encode())
        if self.write_counter % 10 == 0:
            self.file.flush()
        self.write_counter += 1

    def _handle_backspace_char(self):
        """
        If the 'backspace' key is pressed, we need to delete the last character from the file.
        """
        if DEBUG and DEBUG_VERBOSE:
            print(f"Saving parsed 'backspace' to {self}.")
        self.write_counter += 1
        self._truncate_utf8_chars(1, ignore_newlines=False)

    def _truncate_utf8_chars(self, count, ignore_newlines=True):
        """
        Truncates last `count` characters of a text file encoded in UTF-8.
        :param filename: The path to the text file to read
        :param count: Number of UTF-8 characters to remove from the end of the file
        :param ignore_newlines: Set to true, if the newline character at the end of the file should be ignored
        """
        last_char = None

        size = os.fstat(self.file.fileno()).st_size

        offset = 1
        chars = 0
        while offset <= size:
            self.file.seek(-offset, os.SEEK_END)
            current_read_byte = ord(self.file.read(1))

            if ignore_newlines:
                if current_read_byte == 0x0D or current_read_byte == 0x0A:
                    offset += 1
                    continue

            if (
                current_read_byte & 0b10000000 == 0
                or current_read_byte & 0b11000000 == 0b11000000
            ):
                # This is the first byte of a UTF8 character
                chars += 1
                if chars == count:
                    # When `count` number of characters have been found, move current position back
                    # with one byte (to include the byte just checked) and truncate the file
                    self.file.seek(-1, os.SEEK_CUR)
                    self.file.truncate()
                    return
            offset += 1

    def close(self):
        self.file.close()
        self.is_active = False
